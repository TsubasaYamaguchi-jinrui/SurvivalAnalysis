# コックス回帰モデル {#c4}  
前章(\@ref(c3))で解説したパラメトリックモデルは非常に有効である一方で以下の2点の欠点もあった。  

1. 最も適切な分布を決めなくてはならず、それがしばしば難しい  
2. 時間依存的な独立変数を使うことができない  

コックスの比例ハザードモデル[@Cox1972] (**コックス回帰モデル**)はこうした欠点をどちらも解決してくれる優れた分析手法である。  

## 比例ハザードモデル  
コックス回帰モデルはこれまで説明した**パラメトリックな比例ハザードモデルを一般化したもの**といえる。ひとまず、非時間依存な独立変数2つを持つモデルを考えると、比例ハザードモデルは以下のように書ける(式\@ref(eq:eq-cox))。ここで、$a(t)$は時間の関数であり、どんな形でもよい。この形を一定の形に決める必要がないので、このモデルはしばしば「セミパラメトリック」なモデルと呼ばれる。    

$$
log(h(t)) = a(t) + b_1x_1 + b_2x_2 (\#eq:eq-cox) 
$$

任意の時間$t$に対して、個体$i$と$j$のハザード比($h_i(t)/h_j(t)$)の値が一定なので比例ハザードモデルといわれている。第\@ref(c3)章のパラメトリックなモデルはコックス回帰モデルの特殊例である。$a(t)$が定数なら指数分布モデル、$a(t) = ct$ならワイブル回帰モデルになる。$a(t)$はいかなる形も取れるので、例えば以下のような4次の多項式にすることもできる(式\@ref(eq:eq-cox2))。  

$$
log(h(t)) = a_0 + a_1t + a_2t^2 + a_3t^3 + a_4t^4 (\#eq:eq-cox2) 
$$

## 部分尤度法  
コックス回帰モデルでは**部分尤度法**と呼ばれる方法でパラメータの推定を行う。この方法では、尤度関数を偏回帰係数($b_1,b_2$)のみを含む部分と偏回帰係数と関数$a(t)$の両方を含む部分に分解し、前者のみに着目して通常のパラメータ推定を行う。つまり、時間$t$に依存する部分を無視して偏回帰係数のみを推定できるのである。部分尤度法では正確な事象の発生時間ではなく、事象の発生順序のみに基づいて推定が行われるため、時間を二乗したり整数倍しても推定結果は変わらない。  

## Rによる実装  
第\@ref(c3)章で分析した元服役囚の再犯データにコックス回帰モデルを当てはめる。分析には、`survival`パッケージの`coxph()`関数を使用する。  

```{r}
mod_cox <- coxph(Surv(week, arrest) ~ fin + age + race + wexp + mar 
                 + paro + prio, data = recid)
```

結果は以下の通り。係数の推定値自体はワイブル回帰モデルとほとんど変わらない(表\@ref(tab:tab-modelcomparison2)参照)。指数変換された標準偏回帰係数はパラメトリックなモデルと同様にハザード比として解釈できる。例えば、経済的支援を受けた元服役囚は受けてない元服役囚よりも再犯の可能性が約32%低下することが分かる。    
```{r}
mod_cox
```

## 時間に依存する独立変数  
コックス回帰モデルは時間依存的な独立変数を含むモデルに拡張できる(式\@ref(eq:eq-cox3))。  

$$
log(h(t)) = a(t) + b_1x_1 + b_2x_2(t)  (\#eq:eq-cox3) 
$$

独立変数の値の変化とそれがハザード率に与える影響の間にタイムラグがある場合は、例えば以下のように1週間前の値を独立変数にするようにモデリングすることもできる(式\@ref(eq:eq-cox4))。  

$$
log(h(t)) = a(t) + b_1x_1 + b_2x_2(t-1)  (\#eq:eq-cox4) 　　
$$

再犯データのモデルの独立変数に、各週の就業状況(`work`)を加えてモデリングを行う。Rで分析を行う際には、それぞれの人の各週のデータすべてが1行ずつあるようなデータフレームを作成する必要がある。  

```{r}
recid %>% 
  rownames_to_column(var = "id") %>% 
  ### 就業状態を一列に
  pivot_longer(cols = work1:work52,
               names_to = "work_week",
               values_to = "work",
               values_drop_na = TRUE) %>% 
  arrange(id) %>% 
  group_by(id) %>%
  ## 各行データの観察開始時点
  mutate(start = 1:n() -1) %>% 
  ## 各行データの観察終了時点(何週目か)  
  mutate(stop = 1:n()) %>% 
  ## 再犯があった州のarrestのみを1にして、そのほかは0にする  
  mutate(arrest = ifelse(arrest == 1 & week == stop,1,0)) %>% 
  ##1週前の就業状態  
  mutate(worklag = lag(work,1))-> recid_long
```

それでは、時間依存変数を含んだコックス回帰モデルを実行する。まずは式\@ref(eq:eq-cox3)のモデルを推定する。従属変数は、`Surv(start, stop,arrest)`となる点に注意。    
```{r}
mod_cox_ti <- coxph(Surv(start, stop, arrest) ~ fin + age + race + wexp + mar 
                 + paro + prio + work, data = recid_long)
```

結果は以下の通り。  
```{r}
mod_cox_ti
```

続いて、式\@ref(eq:eq-cox4)のモデルを推定する。`work`の代わりに`worklag`を説明変数に入れる。  
```{r}
mod_cox_tlag <- coxph(Surv(start, stop, arrest) ~ fin + age + race + wexp + mar 
                 + paro + prio + worklag, data = recid_long)
```

結果は以下の通り。  
```{r}
mod_cox_tlag
```

推定した3つのモデルの推定値をまとめたものが表\@ref(tab:tab-coxmodelcomp)である。推定結果自体は非常によく似ているが、先ほどの検定結果を見ると経済的支援の効果は時間依存変数を含まない基本モデルのみで有意になっている。また、時間依存変数の就業状態(`work`または`worklag`)が他の変数よりも大きな影響を与えていたことも分かった。、2つ目のモデルのハザード比(`Exp(Coef) = 0.265`)をみると就業している元服役囚の再犯率が就業していない服役囚の26.5%であると推定された。  

ただし、この結果のみでは就業状態が再犯に影響したのか、再犯が就業状態に影響したのかはわからない。そこで、就業状態に1週間のラグがあるモデル3の結果を見ると、2つ目のモデルより効果量は減少するものの、依然として大きな影響を及ぼしていることが分かる。モデル3のハザード比(`Exp(Coef) = 0.455`)から、就業状態にある元服役囚はそうでない元服役囚に比べて翌週の再犯率が約54.5%低いことが分かる。このように、タイムラグを持つ変数を用いることで再犯が就業状態に影響する可能性を除外することができる。    

```{r tab-coxmodelcomp}
tibble(Covariate = rownames(mod_cox_ti$coefficients %>% data.frame()),
       "Coef(basic)" = c(sprintf("%.3f",coef(mod_cox))[1:7],NA),
       "Exp(Coef_basic)" = c(sprintf("%.3f",exp(coef(mod_cox)))[1:7],NA),
       "Coef(ti)" = sprintf("%.3f",coef(mod_cox_ti))[1:8],
       "Exp(Coef_ti)" = sprintf("%.3f",exp(coef(mod_cox_ti)))[1:8],
       "Coef(tlag)" = sprintf("%.3f",coef(mod_cox_tlag))[1:8],
       "Exp(Coef_tlag)" = sprintf("%.3f",exp(coef(mod_cox_tlag))[1:8])) %>% 
  mutate(Covariate = ifelse(str_detect(Covariate,"work"),"work/worklag",Covariate)) %>% 
  flextable() %>% 
  add_header_row(colwidth = c(1,2,2,2),
                 values = c("","基本モデル","時間依存独立変数\nあり", "タイムラグのある\n時間独立変数あり")) %>% 
  flextable::align(align = "center", part = "all") %>% 
  set_caption("各モデルの推定値の比較")
```
<br/>  

## 時間依存独立変数を含むモデル    
時間依存独立変数があるモデルの推定をするとき、ある時点で事象が発生した場合、**その時点で事象を経験しうるすべての個体について時間依存変数の値が分かっていなければいけない**。例えば、$t =10$で事象が発生し、その時点で15人が事象を経験する可能性がある(= リスク集合にいる)場合、15人全員について$t=10$時点の時間依存変数が分かっていなければいけない。そのため、事象の発生が日単位で測定されているにもかかわらず、時間依存変数の値が1週間ごとにしか測定されていないといったことがあるとき、問題が生じることになる。  

このような場合、特定の方法で事象が発生した時点の独立変数の値を**補完して代入**する必要がある。いろいろな方法があるが、最も安全なものは直前に観察された値を使用する方法である。保管によって必要な代入ができたら、次に分析のためにデータを加工する必要がある。加工方法には以下の2つがあるが、統計ソフトではいずれかを使用している(Rはエピソード分割法)。どちらも選べるならば後者の方が望ましい。    

### プログラミング・ステートメント法(programming statements method)  
この方法を使用するには、データをワイド形式にする必要がある。すなわち、今回の例では各週の就業状態が1列ずつになるようにする必要がある。  

### エピソード分割法(episode splitting method)  
この方法のデータは先ほど加工した`recid_long`のようにロング形式で問題ない。それぞれの個体が複数の行を持ち、各行のデータについて観察し始めた時点(`start`)と観察が終了した時点(`stop`)を記した列を作る。また独立変数が変化するたびに行を変えるか、もしくは独立変数の変化に関係なく小さな時間間隔ごとに行を変える(どちらでも問題ない)。例えば`recid_long`では各個体が1週間ごとに1行ずつのデータを持つ。

```{r}
recid_long %>% 
  head(50) %>% 
  datatable(options = list(scrollX = 20))
```

## 比例ハザード性の仮定の検討と修正  

